

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dopterianPlus.dopterian &mdash; Dopterian+ 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Dopterian+
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About Dopterian+</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage_examples.html">Usage Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dopterian.html">dopterian Submodule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../calc_FWHM.html">calc_FWHM Submodule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cut_postage_stamp.html">cut_postage_stamp submodule</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Dopterian+</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">dopterianPlus.dopterian</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dopterianPlus.dopterian</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">scndi</span>
<span class="kn">import</span> <span class="nn">astropy.io.fits</span> <span class="k">as</span> <span class="nn">pyfits</span>
<span class="kn">import</span> <span class="nn">astropy.convolution</span> <span class="k">as</span> <span class="nn">apcon</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span> <span class="k">as</span> <span class="nn">scint</span> 
<span class="kn">import</span> <span class="nn">numpy.random</span> <span class="k">as</span> <span class="nn">npr</span>
<span class="kn">import</span> <span class="nn">astropy.io.fits</span> <span class="k">as</span> <span class="nn">pyfits</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">scopt</span>
<span class="kn">import</span> <span class="nn">astropy.modeling</span> <span class="k">as</span> <span class="nn">apmodel</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">scndi</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">cosmology</span> <span class="k">as</span> <span class="n">cosmos</span>
<span class="kn">import</span> <span class="nn">astropy.convolution</span> <span class="k">as</span> <span class="nn">apcon</span>
<span class="kn">from</span> <span class="nn">astropy.cosmology</span> <span class="kn">import</span> <span class="n">FlatLambdaCDM</span>
<span class="kn">import</span> <span class="nn">kcorrect</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">calc_FWHM</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="n">version</span> <span class="o">=</span> <span class="s1">&#39;1.0.0&#39;</span>   


<span class="n">version</span> <span class="o">=</span> <span class="s1">&#39;1.0.0&#39;</span>   
<span class="n">c</span> <span class="o">=</span> <span class="mf">299792458.</span> <span class="c1">## speed of light</span>


<span class="c1">## SDSS maggies to lupton</span>
<span class="n">magToLup</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;u&#39;</span><span class="p">:</span><span class="mf">1.4e-10</span><span class="p">,</span><span class="s1">&#39;g&#39;</span><span class="p">:</span><span class="mf">0.9e-10</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">:</span><span class="mf">1.2e-10</span><span class="p">,</span><span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="mf">1.8e-10</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">:</span><span class="mf">7.4e-10</span><span class="p">}</span>

<span class="c1">#==============================================================================</span>
<span class="c1"># HELPER FUNCTIONS</span>
<span class="c1">#==============================================================================</span>

<div class="viewcode-block" id="nu2lam">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.nu2lam">[docs]</a>
<span class="k">def</span> <span class="nf">nu2lam</span><span class="p">(</span><span class="n">nu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert frequency from Hz to wavelength in Angstrom.</span>

<span class="sd">    This function takes a frequency value in hertz (Hz) and converts it to</span>
<span class="sd">    wavelength in angstroms using the speed of light.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nu : float</span>
<span class="sd">        Frequency in hertz (Hz).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Wavelength in angstroms.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The speed of light (`c`) is assumed to be a constant defined as 299792458 m/s.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">c</span> <span class="o">/</span> <span class="n">nu</span> <span class="o">*</span> <span class="mf">1e-10</span></div>


    
<div class="viewcode-block" id="lam2nu">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.lam2nu">[docs]</a>
<span class="k">def</span> <span class="nf">lam2nu</span><span class="p">(</span><span class="n">lam</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert wavelength from Angstrom to frequency in Hz.</span>

<span class="sd">    This function takes a wavelength value in angstroms and converts it to </span>
<span class="sd">    frequency in hertz (Hz) using the speed of light.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lam : float</span>
<span class="sd">        Wavelength in angstroms.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Frequency in hertz (Hz).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The speed of light (`c`) is assumed to be a constant defined as 299792458 m/s.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">c</span> <span class="o">/</span> <span class="n">lam</span> <span class="o">*</span> <span class="mf">1e10</span></div>

    

<div class="viewcode-block" id="maggies2mags">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.maggies2mags">[docs]</a>
<span class="k">def</span> <span class="nf">maggies2mags</span><span class="p">(</span><span class="n">maggies</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert flux density from maggies to magnitudes.</span>

<span class="sd">    This function converts a flux density value given in maggies </span>
<span class="sd">    to the astronomical magnitude scale.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    maggies : float or ndarray</span>
<span class="sd">        Flux density in maggies.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or ndarray</span>
<span class="sd">        Equivalent magnitude(s) in the astronomical scale.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">maggies</span><span class="p">)</span></div>



<div class="viewcode-block" id="mags2maggies">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.mags2maggies">[docs]</a>
<span class="k">def</span> <span class="nf">mags2maggies</span><span class="p">(</span><span class="n">mags</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert magnitudes to flux density in maggies.</span>

<span class="sd">    This function converts an astronomical magnitude value </span>
<span class="sd">    to the equivalent flux density in maggies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mags : float or ndarray</span>
<span class="sd">        Astronomical magnitude(s).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or ndarray</span>
<span class="sd">        Equivalent flux density in maggies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.4</span> <span class="o">*</span> <span class="n">mags</span><span class="p">)</span></div>



<div class="viewcode-block" id="maggies2fnu">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.maggies2fnu">[docs]</a>
<span class="k">def</span> <span class="nf">maggies2fnu</span><span class="p">(</span><span class="n">maggies</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert flux density from maggies to units of [erg s⁻¹ Hz⁻¹ cm⁻²].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    maggies : float or ndarray</span>
<span class="sd">        Flux density in maggies.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or ndarray</span>
<span class="sd">        Flux density in units of [erg s⁻¹ Hz⁻¹ cm⁻²].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mf">3531e-23</span> <span class="o">*</span> <span class="n">maggies</span></div>



<div class="viewcode-block" id="fnu2maggies">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.fnu2maggies">[docs]</a>
<span class="k">def</span> <span class="nf">fnu2maggies</span><span class="p">(</span><span class="n">fnu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert flux density from units of [erg s⁻¹ Hz⁻¹ cm⁻²] to maggies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fnu : float or ndarray</span>
<span class="sd">        Flux density in units of [erg s⁻¹ Hz⁻¹ cm⁻²].</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or ndarray</span>
<span class="sd">        Flux density in maggies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mf">3631e23</span> <span class="o">*</span> <span class="n">fnu</span></div>



<div class="viewcode-block" id="fnu2flam">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.fnu2flam">[docs]</a>
<span class="k">def</span> <span class="nf">fnu2flam</span><span class="p">(</span><span class="n">fnu</span><span class="p">,</span> <span class="n">lam</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert flux density from frequency space (fnu) to wavelength space (flam).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fnu : float or ndarray</span>
<span class="sd">        Flux density in units of [erg s⁻¹ Hz⁻¹ cm⁻²].</span>
<span class="sd">    lam : float or ndarray</span>
<span class="sd">        Wavelength in angstroms.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or ndarray</span>
<span class="sd">        Flux density in units of [erg s⁻¹ Å⁻¹ cm⁻²].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">c</span> <span class="o">*</span> <span class="mf">1e10</span> <span class="o">/</span> <span class="n">lam</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fnu</span></div>



<div class="viewcode-block" id="flam2fnu">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.flam2fnu">[docs]</a>
<span class="k">def</span> <span class="nf">flam2fnu</span><span class="p">(</span><span class="n">flam</span><span class="p">,</span> <span class="n">lam</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert flux density from wavelength space (flam) to frequency space (fnu).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    flam : float or ndarray</span>
<span class="sd">        Flux density in units of [erg s⁻¹ Å⁻¹ cm⁻²].</span>
<span class="sd">    lam : float or ndarray</span>
<span class="sd">        Wavelength in angstroms.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or ndarray</span>
<span class="sd">        Flux density in units of [erg s⁻¹ Hz⁻¹ cm⁻²].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">flam</span> <span class="o">/</span> <span class="n">c</span> <span class="o">/</span> <span class="mf">1.0e10</span> <span class="o">*</span> <span class="n">lam</span><span class="o">**</span><span class="mi">2</span></div>



<div class="viewcode-block" id="lambda_eff">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.lambda_eff">[docs]</a>
<span class="k">def</span> <span class="nf">lambda_eff</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">trans</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the effective wavelength of a filter.</span>

<span class="sd">    This function computes the mean wavelength of a filter by integrating </span>
<span class="sd">    the product of wavelength and transmission over the wavelength range.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lam : ndarray</span>
<span class="sd">        Wavelength array in angstroms.</span>
<span class="sd">    trans : ndarray</span>
<span class="sd">        Transmission values corresponding to the wavelength array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Effective wavelength in angstroms.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If all wavelengths in `lam` are zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indexs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lam</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ERROR: no non-zero wavelengths&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Lambda</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">lam</span><span class="p">[</span><span class="n">indexs</span><span class="p">])</span>
        <span class="n">Transmission</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">trans</span><span class="p">[</span><span class="n">indexs</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">scint</span><span class="o">.</span><span class="n">simps</span><span class="p">(</span><span class="n">Lambda</span> <span class="o">*</span> <span class="n">Transmission</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">)</span> <span class="o">/</span> <span class="n">scint</span><span class="o">.</span><span class="n">simps</span><span class="p">(</span><span class="n">Transmission</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">)</span></div>

    

<div class="viewcode-block" id="cts2maggies">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.cts2maggies">[docs]</a>
<span class="k">def</span> <span class="nf">cts2maggies</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">exptime</span><span class="p">,</span> <span class="n">zp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert counts to flux density in maggies.</span>

<span class="sd">    This function calculates flux density in maggies from the total counts, </span>
<span class="sd">    exposure time, and zero-point magnitude.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cts : float or ndarray</span>
<span class="sd">        Total counts from the observation.</span>
<span class="sd">    exptime : float</span>
<span class="sd">        Exposure time in seconds.</span>
<span class="sd">    zp : float</span>
<span class="sd">        Zero-point magnitude.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or ndarray</span>
<span class="sd">        Flux density in maggies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cts</span> <span class="o">/</span> <span class="n">exptime</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.4</span> <span class="o">*</span> <span class="n">zp</span><span class="p">)</span></div>


    
<div class="viewcode-block" id="cts2mags">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.cts2mags">[docs]</a>
<span class="k">def</span> <span class="nf">cts2mags</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">exptime</span><span class="p">,</span> <span class="n">zp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert counts to magnitudes.</span>

<span class="sd">    This function calculates astronomical magnitudes from the total counts, </span>
<span class="sd">    exposure time, and zero-point magnitude.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cts : float or ndarray</span>
<span class="sd">        Total counts from the observation.</span>
<span class="sd">    exptime : float</span>
<span class="sd">        Exposure time in seconds.</span>
<span class="sd">    zp : float</span>
<span class="sd">        Zero-point magnitude.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or ndarray</span>
<span class="sd">        Astronomical magnitudes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">maggies2mags</span><span class="p">(</span><span class="n">cts2maggies</span><span class="p">(</span><span class="n">cts</span><span class="p">,</span> <span class="n">exptime</span><span class="p">,</span> <span class="n">zp</span><span class="p">))</span></div>



<div class="viewcode-block" id="maggies2cts">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.maggies2cts">[docs]</a>
<span class="k">def</span> <span class="nf">maggies2cts</span><span class="p">(</span><span class="n">maggies</span><span class="p">,</span> <span class="n">exptime</span><span class="p">,</span> <span class="n">zp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert flux density in maggies to counts.</span>

<span class="sd">    This function calculates the total counts from flux density in maggies, </span>
<span class="sd">    exposure time, and zero-point magnitude.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    maggies : float or ndarray</span>
<span class="sd">        Flux density in maggies.</span>
<span class="sd">    exptime : float</span>
<span class="sd">        Exposure time in seconds.</span>
<span class="sd">    zp : float</span>
<span class="sd">        Zero-point magnitude.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or ndarray</span>
<span class="sd">        Total counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">maggies</span> <span class="o">*</span> <span class="n">exptime</span> <span class="o">/</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.4</span> <span class="o">*</span> <span class="n">zp</span><span class="p">)</span></div>


    
<div class="viewcode-block" id="mags2cts">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.mags2cts">[docs]</a>
<span class="k">def</span> <span class="nf">mags2cts</span><span class="p">(</span><span class="n">mags</span><span class="p">,</span> <span class="n">exptime</span><span class="p">,</span> <span class="n">zp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert magnitudes to counts.</span>

<span class="sd">    This function calculates the total counts from astronomical magnitudes, </span>
<span class="sd">    exposure time, and zero-point magnitude.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mags : float or ndarray</span>
<span class="sd">        Astronomical magnitudes.</span>
<span class="sd">    exptime : float</span>
<span class="sd">        Exposure time in seconds.</span>
<span class="sd">    zp : float</span>
<span class="sd">        Zero-point magnitude.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or ndarray</span>
<span class="sd">        Total counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">maggies2cts</span><span class="p">(</span><span class="n">mags2maggies</span><span class="p">(</span><span class="n">mags</span><span class="p">),</span> <span class="n">exptime</span><span class="p">,</span> <span class="n">zp</span><span class="p">)</span></div>



<div class="viewcode-block" id="maggies2lup">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.maggies2lup">[docs]</a>
<span class="k">def</span> <span class="nf">maggies2lup</span><span class="p">(</span><span class="n">maggies</span><span class="p">,</span> <span class="n">filtro</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert flux density in maggies to Lupton magnitudes.</span>

<span class="sd">    This function calculates Lupton magnitudes from flux density in maggies</span>
<span class="sd">    for a given filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    maggies : float or ndarray</span>
<span class="sd">        Flux density in maggies.</span>
<span class="sd">    filtro : str</span>
<span class="sd">        Filter name (e.g., &#39;u&#39;, &#39;g&#39;, &#39;r&#39;, &#39;i&#39;, &#39;z&#39;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or ndarray</span>
<span class="sd">        Lupton magnitudes.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The conversion relies on a predefined mapping of filters to their corresponding</span>
<span class="sd">    scaling factor (`magToLup` dictionary).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">magToLup</span><span class="p">[</span><span class="n">filtro</span><span class="p">]</span>
    <span class="k">return</span> <span class="o">-</span><span class="mf">2.5</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arcsinh</span><span class="p">(</span><span class="n">maggies</span> <span class="o">/</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">))</span></div>

    
<div class="viewcode-block" id="lup2maggies">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.lup2maggies">[docs]</a>
<span class="k">def</span> <span class="nf">lup2maggies</span><span class="p">(</span><span class="n">lup</span><span class="p">,</span> <span class="n">filtro</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Lupton magnitudes to flux density in maggies.</span>

<span class="sd">    This function calculates flux density in maggies from Lupton magnitudes</span>
<span class="sd">    for a given filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lup : float or ndarray</span>
<span class="sd">        Lupton magnitudes.</span>
<span class="sd">    filtro : str</span>
<span class="sd">        Filter name (e.g., &#39;u&#39;, &#39;g&#39;, &#39;r&#39;, &#39;i&#39;, &#39;z&#39;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or ndarray</span>
<span class="sd">        Flux density in maggies.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The conversion relies on a predefined mapping of filters to their corresponding</span>
<span class="sd">    scaling factor (`magToLup` dictionary).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">magToLup</span><span class="p">[</span><span class="n">filtro</span><span class="p">]</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="o">-</span><span class="mf">0.4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">lup</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">))</span></div>


    
<div class="viewcode-block" id="random_indices">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.random_indices">[docs]</a>
<span class="k">def</span> <span class="nf">random_indices</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">indexs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a random selection of unique indices.</span>

<span class="sd">    This function returns an array containing a specified number of unique</span>
<span class="sd">    indices randomly chosen from a given list or array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    size : int</span>
<span class="sd">        Number of unique indices to select.</span>
<span class="sd">    indexs : array-like</span>
<span class="sd">        Array or list of indices to sample from.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Array of randomly selected unique indices.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `size` is larger than the number of available indices in `indexs`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">npr</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indexs</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="edge_index">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.edge_index">[docs]</a>
<span class="k">def</span> <span class="nf">edge_index</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate indices of a ring-shaped region in a 2D array.</span>

<span class="sd">    This function creates an index list of elements forming a ring with a </span>
<span class="sd">    width of 1 around the center of the array, defined by radii `rx` and `ry`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Input 2D array.</span>
<span class="sd">    rx : int</span>
<span class="sd">        Radius along the x-axis from the center of the array.</span>
<span class="sd">    ry : int</span>
<span class="sd">        Radius along the y-axis from the center of the array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple of ndarrays</span>
<span class="sd">        Tuple containing the row and column indices of the ring elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="p">))</span>
    
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">XX</span> <span class="o">-</span> <span class="n">N</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">YY</span> <span class="o">-</span> <span class="n">M</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(((</span><span class="n">X</span> <span class="o">==</span> <span class="n">rx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Y</span> <span class="o">&lt;=</span> <span class="n">ry</span><span class="p">))</span> <span class="o">+</span> <span class="p">((</span><span class="n">Y</span> <span class="o">==</span> <span class="n">ry</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span> <span class="o">&lt;=</span> <span class="n">rx</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">idx</span></div>



<div class="viewcode-block" id="predict_redshifted_FWHM">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.predict_redshifted_FWHM">[docs]</a>
<span class="k">def</span> <span class="nf">predict_redshifted_FWHM</span><span class="p">(</span><span class="n">a_low</span><span class="p">,</span> <span class="n">z_low</span><span class="p">,</span> <span class="n">z_high</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predict the Full Width at Half Maximum (FWHM) at a higher redshift.</span>

<span class="sd">    This function calculates the predicted FWHM at a higher redshift based on</span>
<span class="sd">    the FWHM at a lower redshift and the corresponding luminosity distances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a_low : float</span>
<span class="sd">        FWHM at the lower redshift.</span>
<span class="sd">    z_low : float</span>
<span class="sd">        Lower redshift value.</span>
<span class="sd">    z_high : float</span>
<span class="sd">        Higher redshift value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Predicted FWHM at the higher redshift.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The calculation considers the luminosity distances and scaling factors </span>
<span class="sd">    for the redshifts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d_low</span> <span class="o">=</span> <span class="n">cosmos</span><span class="o">.</span><span class="n">luminosity_distance</span><span class="p">(</span><span class="n">z_low</span><span class="p">)</span> 
    <span class="n">d_high</span> <span class="o">=</span> <span class="n">cosmos</span><span class="o">.</span><span class="n">luminosity_distance</span><span class="p">(</span><span class="n">z_high</span><span class="p">)</span>

    <span class="n">a_high</span> <span class="o">=</span> <span class="n">a_low</span> <span class="o">*</span> <span class="p">(</span><span class="n">d_low</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z_low</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">d_high</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z_high</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">a_high</span></div>



<div class="viewcode-block" id="check_PSF_FWHM">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.check_PSF_FWHM">[docs]</a>
<span class="k">def</span> <span class="nf">check_PSF_FWHM</span><span class="p">(</span><span class="n">psf_low</span><span class="p">,</span> <span class="n">psf_high</span><span class="p">,</span> <span class="n">pixcale_low_z</span><span class="p">,</span> <span class="n">pixscale_high_z</span><span class="p">,</span> <span class="n">z_low</span><span class="p">,</span> <span class="n">z_high</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Verify if the PSF FWHM at low redshift is compatible with the PSF at high redshift.</span>

<span class="sd">    This function checks whether the redshifted FWHM of the PSF at low redshift</span>
<span class="sd">    is smaller than or equal to the FWHM of the PSF at high redshift.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psf_low : ndarray</span>
<span class="sd">        PSF image at the lower redshift.</span>
<span class="sd">    psf_high : ndarray</span>
<span class="sd">        PSF image at the higher redshift.</span>
<span class="sd">    pixcale_low_z : float</span>
<span class="sd">        Pixel scale at the lower redshift.</span>
<span class="sd">    pixscale_high_z : float</span>
<span class="sd">        Pixel scale at the higher redshift.</span>
<span class="sd">    z_low : float</span>
<span class="sd">        Lower redshift value.</span>
<span class="sd">    z_high : float</span>
<span class="sd">        Higher redshift value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        True if the redshifted low-z PSF FWHM is compatible with the high-z PSF,</span>
<span class="sd">        False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">low_z_fwhm</span> <span class="o">=</span> <span class="n">calc_FWHM</span><span class="o">.</span><span class="n">calc_FWHM</span><span class="p">(</span><span class="n">psf_low</span><span class="p">,</span> <span class="n">pixcale_low_z</span><span class="p">)</span>
    <span class="n">high_z_fwhm</span> <span class="o">=</span> <span class="n">calc_FWHM</span><span class="o">.</span><span class="n">calc_FWHM</span><span class="p">(</span><span class="n">psf_high</span><span class="p">,</span> <span class="n">pixscale_high_z</span><span class="p">)</span>

    <span class="n">redshifted_low_z_fwhm</span> <span class="o">=</span> <span class="n">predict_redshifted_FWHM</span><span class="p">(</span><span class="n">low_z_fwhm</span><span class="p">,</span> <span class="n">z_low</span><span class="p">,</span> <span class="n">z_high</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">redshifted_low_z_fwhm</span> <span class="o">&gt;</span> <span class="n">high_z_fwhm</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="k">return</span> <span class="kc">True</span></div>

    

<div class="viewcode-block" id="predict_redshifted_image_size">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.predict_redshifted_image_size">[docs]</a>
<span class="k">def</span> <span class="nf">predict_redshifted_image_size</span><span class="p">(</span><span class="n">z_low</span><span class="p">,</span> <span class="n">z_high</span><span class="p">,</span> <span class="n">n_low</span><span class="p">,</span> <span class="n">pixscale_low_z</span><span class="p">,</span> <span class="n">pixscale_high_z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predict the image size at a higher redshift.</span>

<span class="sd">    This function calculates the expected size of an image at a higher redshift</span>
<span class="sd">    based on its size at a lower redshift, accounting for luminosity distances,</span>
<span class="sd">    redshift scaling factors, and pixel scales.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z_low : float</span>
<span class="sd">        Lower redshift value.</span>
<span class="sd">    z_high : float</span>
<span class="sd">        Higher redshift value.</span>
<span class="sd">    n_low : int</span>
<span class="sd">        Image size (number of pixels) at the lower redshift.</span>
<span class="sd">    pixscale_low_z : float</span>
<span class="sd">        Pixel scale at the lower redshift.</span>
<span class="sd">    pixscale_high_z : float</span>
<span class="sd">        Pixel scale at the higher redshift.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Predicted image size (number of pixels) at the higher redshift.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d_low</span> <span class="o">=</span> <span class="n">cosmos</span><span class="o">.</span><span class="n">luminosity_distance</span><span class="p">(</span><span class="n">z_low</span><span class="p">)</span> 
    <span class="n">d_high</span> <span class="o">=</span> <span class="n">cosmos</span><span class="o">.</span><span class="n">luminosity_distance</span><span class="p">(</span><span class="n">z_high</span><span class="p">)</span>

    <span class="n">mag_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">d_low</span> <span class="o">/</span> <span class="n">d_high</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z_high</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">z_low</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pixscale_low_z</span> <span class="o">/</span> <span class="n">pixscale_high_z</span><span class="p">)</span>
    
    <span class="n">n_high</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">n_low</span> <span class="o">*</span> <span class="n">mag_factor</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">n_high</span></div>

   

<div class="viewcode-block" id="dist_ellipse">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.dist_ellipse">[docs]</a>
<span class="k">def</span> <span class="nf">dist_ellipse</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">ang</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute distances to the center in elliptical apertures.</span>

<span class="sd">    This function calculates the distance of each pixel in an image</span>
<span class="sd">    to the center `(xc, yc)` using elliptical apertures, accounting</span>
<span class="sd">    for axis ratio and rotation angle.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : ndarray</span>
<span class="sd">        Input 2D image.</span>
<span class="sd">    xc : float</span>
<span class="sd">        X-coordinate of the center.</span>
<span class="sd">    yc : float</span>
<span class="sd">        Y-coordinate of the center.</span>
<span class="sd">    q : float</span>
<span class="sd">        Axis ratio of the ellipse (minor/major).</span>
<span class="sd">    ang : float</span>
<span class="sd">        Rotation angle of the ellipse in degrees.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A 2D array where each value represents the distance of the</span>
<span class="sd">        corresponding pixel to the center `(xc, yc)` in the elliptical frame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="n">rX</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">xc</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">Y</span> <span class="o">-</span> <span class="n">yc</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
    <span class="n">rY</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">xc</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span> <span class="o">-</span> <span class="n">yc</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span>
    <span class="n">dmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rX</span> <span class="o">*</span> <span class="n">rX</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">q</span><span class="p">))</span> <span class="o">*</span> <span class="n">rY</span> <span class="o">*</span> <span class="n">rY</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dmat</span></div>



<div class="viewcode-block" id="robust_linefit">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.robust_linefit">[docs]</a>
<span class="k">def</span> <span class="nf">robust_linefit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a robust linear fit.</span>

<span class="sd">    This function fits a robust linear model to the data using the</span>
<span class="sd">    HuberT norm to reduce the influence of outliers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array-like</span>
<span class="sd">        Independent variable.</span>
<span class="sd">    y : array-like</span>
<span class="sd">        Dependent variable.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Parameters of the fitted linear model, where the first element</span>
<span class="sd">        is the intercept and the second element is the slope.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function uses the `RLM` (Robust Linear Model) from the `statsmodels`</span>
<span class="sd">    library with the HuberT norm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Agrega una constante para el término independiente</span>
    <span class="n">robust_model</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">RLM</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">sm</span><span class="o">.</span><span class="n">robust</span><span class="o">.</span><span class="n">norms</span><span class="o">.</span><span class="n">HuberT</span><span class="p">())</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">robust_model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">params</span></div>


<div class="viewcode-block" id="resistent_mean">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.resistent_mean">[docs]</a>
<span class="k">def</span> <span class="nf">resistent_mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the mean value of an array using a k-sigma clipping method.</span>

<span class="sd">    This function iteratively removes outliers beyond `k` standard deviations</span>
<span class="sd">    from the mean, recalculating the mean and standard deviation until no</span>
<span class="sd">    outliers remain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like </span>
<span class="sd">        Input array of values.</span>
<span class="sd">    k : float</span>
<span class="sd">        Number of standard deviations for clipping.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Clipped mean of the array.</span>
<span class="sd">    float</span>
<span class="sd">        Clipped standard deviation of the array.</span>
<span class="sd">    int</span>
<span class="sd">        Number of rejected outliers.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Values of zero in the input array are excluded from the calculations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">media</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">back</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">back</span> <span class="o">=</span> <span class="n">back</span><span class="p">[</span><span class="n">back</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="n">media</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">dev</span>
    <span class="n">npix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">npix</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">back</span> <span class="o">=</span> <span class="n">back</span><span class="p">[</span><span class="n">back</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">]</span>
        <span class="n">media</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">back</span><span class="p">)</span>
        <span class="n">dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">back</span><span class="p">)</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="n">media</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">dev</span>
        <span class="n">npix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">back</span><span class="p">[</span><span class="n">back</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">])</span>
        
    <span class="n">nrej</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">media</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">nrej</span></div>



<div class="viewcode-block" id="ring_sky">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.ring_sky">[docs]</a>
<span class="k">def</span> <span class="nf">ring_sky</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">width0</span><span class="p">,</span> <span class="n">nap</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pa</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rstart</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nw</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Measure the flux around a position in elliptical rings.</span>

<span class="sd">    This function calculates the flux around a specified position `(x, y)`</span>
<span class="sd">    in elliptical rings with a given axis ratio, position angle, and</span>
<span class="sd">    aperture configuration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        Input 2D image array.</span>
<span class="sd">    width0 : float</span>
<span class="sd">        Initial width of the rings in pixels.</span>
<span class="sd">    nap : int</span>
<span class="sd">        Number of apertures. Must be greater than 3.</span>
<span class="sd">    x : float, optional</span>
<span class="sd">        X-coordinate of the center. Defaults to the image center.</span>
<span class="sd">    y : float, optional</span>
<span class="sd">        Y-coordinate of the center. Defaults to the image center.</span>
<span class="sd">    q : float, optional</span>
<span class="sd">        Axis ratio of the ellipse (minor/major). Defaults to 1 (circular).</span>
<span class="sd">    pa : float, optional</span>
<span class="sd">        Position angle of the ellipse in degrees. Defaults to 0.</span>
<span class="sd">    rstart : float, optional</span>
<span class="sd">        Starting radius for the rings. Defaults to 5% of the smallest image dimension.</span>
<span class="sd">    nw : int, optional</span>
<span class="sd">        If set, limits the number of apertures to `nw`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Measured sky flux in the elliptical rings.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `nap` is less than or equal to 3.</span>
<span class="sd">        If only one of `x` or `y` is specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nap</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of apertures must be greater than 3.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">rstart</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rstart</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="mf">0.5</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">M</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;X and Y must both be set to a value&#39;</span><span class="p">)</span>

    <span class="n">rad</span> <span class="o">=</span> <span class="n">dist_ellipse</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">pa</span><span class="p">)</span>
    <span class="n">max_rad</span> <span class="o">=</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">rad</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">nw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">width0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">max_rad</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">width0</span><span class="p">)</span>
    
    <span class="n">media</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">nrej</span> <span class="o">=</span> <span class="n">resistent_mean</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">nrej</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">rstart</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rhi</span> <span class="o">=</span> <span class="n">width</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rhi</span> <span class="o">=</span> <span class="n">rstart</span>
    
    <span class="n">nmeasures</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">rhi</span> <span class="o">&lt;=</span> <span class="n">max_rad</span><span class="p">:</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">ct</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">rad</span> <span class="o">&lt;=</span> <span class="n">rhi</span> <span class="o">+</span> <span class="n">extra</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rad</span> <span class="o">&gt;=</span> <span class="n">rhi</span> <span class="o">-</span> <span class="n">extra</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">sig</span><span class="p">)</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">extra</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">extra</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">break</span>
            
        <span class="k">if</span> <span class="n">ct</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">sky</span> <span class="o">=</span> <span class="n">flux</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sky</span> <span class="o">=</span> <span class="n">resistent_mean</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rhi</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">width</span><span class="p">)</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="n">sky</span><span class="p">)</span>
        
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nap</span><span class="p">:</span>
            <span class="n">valid_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">nap</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">nap</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pars</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">scopt</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">nap</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">][</span><span class="n">valid_indices</span><span class="p">],</span> <span class="n">flux</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">nap</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">][</span><span class="n">valid_indices</span><span class="p">])</span>
                <span class="n">slope</span> <span class="o">=</span> <span class="n">pars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">slope</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nmeasures</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">slope</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">nmeasures</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">rhi</span> <span class="o">+=</span> <span class="n">width</span>
    <span class="n">sky</span> <span class="o">=</span> <span class="n">resistent_mean</span><span class="p">(</span><span class="n">flux</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">nap</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">i</span><span class="p">],</span> <span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>        
    <span class="k">return</span> <span class="n">sky</span></div>



<div class="viewcode-block" id="ferengi_make_psf_same">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.ferengi_make_psf_same">[docs]</a>
<span class="k">def</span> <span class="nf">ferengi_make_psf_same</span><span class="p">(</span><span class="n">psf1</span><span class="p">,</span> <span class="n">psf2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjust the sizes of two PSF images by zero-padding the smaller one.</span>

<span class="sd">    This function compares the sizes of two PSF (Point Spread Function) images</span>
<span class="sd">    and pads the smaller image with zeros to match the size of the larger image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psf1 : ndarray</span>
<span class="sd">        First PSF image.</span>
<span class="sd">    psf2 : ndarray</span>
<span class="sd">        Second PSF image.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple of ndarray</span>
<span class="sd">        A tuple containing the two PSF images with matching sizes. The order</span>
<span class="sd">        corresponds to the input: `(psf1, psf2)` or `(psf2, psf1)` depending</span>
<span class="sd">        on which was smaller.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The padding is applied symmetrically, centering the smaller PSF within the</span>
<span class="sd">    larger PSF&#39;s dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">psf1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">psf2</span><span class="p">):</span>
        <span class="n">case</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">big</span> <span class="o">=</span> <span class="n">psf1</span>
        <span class="n">small</span> <span class="o">=</span> <span class="n">psf2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">big</span> <span class="o">=</span> <span class="n">psf2</span>
        <span class="n">small</span> <span class="o">=</span> <span class="n">psf1</span>
        <span class="n">case</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">Nb</span><span class="p">,</span> <span class="n">Mb</span> <span class="o">=</span> <span class="n">big</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">Ns</span><span class="p">,</span> <span class="n">Ms</span> <span class="o">=</span> <span class="n">small</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="n">center</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">Nb</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">small_side</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">Ns</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">new_small</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">big</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">new_small</span><span class="p">[</span><span class="n">center</span><span class="o">-</span><span class="n">small_side</span><span class="p">:</span><span class="n">center</span><span class="o">+</span><span class="n">small_side</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">center</span><span class="o">-</span><span class="n">small_side</span><span class="p">:</span><span class="n">center</span><span class="o">+</span><span class="n">small_side</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">small</span>
    <span class="k">if</span> <span class="n">case</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">psf1</span><span class="p">,</span> <span class="n">new_small</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_small</span><span class="p">,</span> <span class="n">psf2</span></div>



<div class="viewcode-block" id="barycenter">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.barycenter">[docs]</a>
<span class="k">def</span> <span class="nf">barycenter</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">segmap</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the barycenter of a galaxy from an image and segmentation map.</span>

<span class="sd">    This function calculates the barycenter (center of mass) of a galaxy</span>
<span class="sd">    using its intensity values in the input image and a corresponding</span>
<span class="sd">    segmentation map.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : ndarray</span>
<span class="sd">        2D image array representing the intensity of the galaxy.</span>
<span class="sd">    segmap : ndarray</span>
<span class="sd">        2D segmentation map where the galaxy is defined. Values should be </span>
<span class="sd">        binary (1 for the galaxy and 0 for the background).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple of float</span>
<span class="sd">        Coordinates of the barycenter `(X, Y)`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The barycenter is computed as a weighted average of the pixel positions,</span>
<span class="sd">    where the weights are given by the intensity values in `img` masked by</span>
<span class="sd">    `segmap`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
    <span class="n">gal</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">img</span> <span class="o">*</span> <span class="n">segmap</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">gal</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">YY</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">gal</span><span class="p">)</span>     
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span></div>



<div class="viewcode-block" id="ferengi_psf_centre">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.ferengi_psf_centre">[docs]</a>
<span class="k">def</span> <span class="nf">ferengi_psf_centre</span><span class="p">(</span><span class="n">psf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Center the PSF image using its light barycenter.</span>

<span class="sd">    This function shifts the input PSF (Point Spread Function) image so that</span>
<span class="sd">    its barycenter aligns with the center of the image grid. If the PSF is not</span>
<span class="sd">    square, an error is raised.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psf : ndarray</span>
<span class="sd">        2D array representing the PSF image.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        PSF image with the barycenter aligned to the center of the grid.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        If the input PSF is not square.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If warnings occur during the Gaussian fit to the PSF, the barycenter is</span>
<span class="sd">    approximated as the geometric center of the grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">psf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">psf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">psf</span> <span class="o">=</span> <span class="n">psf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  

    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">psf</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">assert</span> <span class="n">N</span> <span class="o">==</span> <span class="n">M</span><span class="p">,</span> <span class="s1">&#39;PSF image must be square&#39;</span>
    
    <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">center_psf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">center_psf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">])</span>

    <span class="n">center_psf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">M</span><span class="p">]</span> <span class="o">=</span> <span class="n">psf</span>
    <span class="n">N1</span><span class="p">,</span> <span class="n">M1</span> <span class="o">=</span> <span class="n">center_psf</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">barycenter</span><span class="p">(</span><span class="n">center_psf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">center_psf</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">G2D_model</span> <span class="o">=</span> <span class="n">apmodel</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">Gaussian2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">psf</span><span class="p">),</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="n">fit_data</span> <span class="o">=</span> <span class="n">apmodel</span><span class="o">.</span><span class="n">fitting</span><span class="o">.</span><span class="n">LevMarLSQFitter</span><span class="p">()</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M1</span><span class="p">))</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="n">fit_data</span><span class="p">(</span><span class="n">G2D_model</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">center_psf</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cenY</span> <span class="o">=</span> <span class="n">pars</span><span class="o">.</span><span class="n">x_mean</span><span class="o">.</span><span class="n">value</span>
        <span class="n">cenX</span> <span class="o">=</span> <span class="n">pars</span><span class="o">.</span><span class="n">y_mean</span><span class="o">.</span><span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">warn</span> <span class="ow">in</span> <span class="n">w</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">warn</span><span class="p">)</span>
        <span class="n">cenX</span> <span class="o">=</span> <span class="n">center_psf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="n">cenY</span> <span class="o">=</span> <span class="n">center_psf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span>
    
    <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">cenX</span> <span class="o">-</span> <span class="n">center_psf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">cenY</span> <span class="o">-</span> <span class="n">center_psf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="n">center_psf</span> <span class="o">=</span> <span class="n">scndi</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">center_psf</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">dx</span><span class="p">,</span> <span class="o">-</span><span class="n">dy</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">center_psf</span></div>

    

<div class="viewcode-block" id="ferengi_deconvolve">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.ferengi_deconvolve">[docs]</a>
<span class="k">def</span> <span class="nf">ferengi_deconvolve</span><span class="p">(</span><span class="n">wide</span><span class="p">,</span> <span class="n">narrow</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the transformation PSF between two PSF images.</span>

<span class="sd">    This function calculates the transformation PSF that maps one PSF </span>
<span class="sd">    (narrow-field) to another (wide-field) in the Fourier domain. The result</span>
<span class="sd">    can be used to simulate or analyze how one optical system relates to another.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wide : ndarray</span>
<span class="sd">        Wide-field PSF image.</span>
<span class="sd">    narrow : ndarray</span>
<span class="sd">        Narrow-field PSF image. Must have the same shape as `wide`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Transformation PSF used to map the narrow-field PSF to the wide-field PSF.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Both PSF images must be centered (odd pixel dimensions) and normalized.</span>
<span class="sd">    - The computation involves zero-padding to ensure compatibility for Fourier transforms.</span>
<span class="sd">    - The maximum array size for processing is capped at 2048x2048 pixels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Nn</span><span class="p">,</span> <span class="n">Mn</span> <span class="o">=</span> <span class="n">narrow</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># Assumes narrow and wide have the same shape</span>

    <span class="n">smax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">Nn</span><span class="p">,</span> <span class="n">Mn</span><span class="p">)</span> 
    <span class="n">bigsz</span> <span class="o">=</span> <span class="mi">2</span>    
    <span class="k">while</span> <span class="n">bigsz</span> <span class="o">&lt;</span> <span class="n">smax</span><span class="p">:</span>
        <span class="n">bigsz</span> <span class="o">*=</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">bigsz</span> <span class="o">&gt;</span> <span class="mi">2048</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Requested PSF array is larger than 2x2k!&#39;</span><span class="p">)</span>
    
    <span class="n">psf_n_2k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">bigsz</span><span class="p">,</span> <span class="n">bigsz</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">psf_w_2k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">bigsz</span><span class="p">,</span> <span class="n">bigsz</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    
    <span class="n">psf_n_2k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Nn</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">Mn</span><span class="p">]</span> <span class="o">=</span> <span class="n">narrow</span>
    <span class="n">psf_w_2k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Nn</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">Mn</span><span class="p">]</span> <span class="o">=</span> <span class="n">wide</span>
    
    <span class="n">psf_n_2k</span> <span class="o">=</span> <span class="n">psf_n_2k</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
    <span class="n">psf_w_2k</span> <span class="o">=</span> <span class="n">psf_w_2k</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
    <span class="n">fft_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">psf_n_2k</span><span class="p">)</span>
    <span class="n">fft_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">psf_w_2k</span><span class="p">)</span>
    
    <span class="n">fft_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">fft_n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">fft_n</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-9</span><span class="p">)</span> <span class="o">*</span> <span class="n">fft_n</span>
    <span class="n">fft_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">fft_w</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">fft_w</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-9</span><span class="p">)</span> <span class="o">*</span> <span class="n">fft_w</span>
    
    <span class="n">psf_ratio</span> <span class="o">=</span> <span class="n">fft_w</span> <span class="o">/</span> <span class="n">fft_n</span>

    <span class="n">psf_intermed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">psf_ratio</span><span class="p">))</span>
    <span class="n">psf_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">narrow</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="n">bigsz</span> <span class="o">-</span> <span class="n">Nn</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="n">Nn</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">psf_corr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">hi</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">hi</span><span class="p">]</span> <span class="o">=</span> <span class="n">psf_intermed</span><span class="p">[</span><span class="n">lo</span><span class="p">:</span><span class="n">bigsz</span><span class="p">,</span> <span class="n">lo</span><span class="p">:</span><span class="n">bigsz</span><span class="p">]</span>    
    <span class="n">psf_corr</span><span class="p">[</span><span class="n">hi</span><span class="p">:</span><span class="n">Nn</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">hi</span><span class="p">]</span> <span class="o">=</span> <span class="n">psf_intermed</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">hi</span><span class="p">,</span> <span class="n">lo</span><span class="p">:</span><span class="n">bigsz</span><span class="p">]</span>    
    <span class="n">psf_corr</span><span class="p">[</span><span class="n">hi</span><span class="p">:</span><span class="n">Nn</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">:</span><span class="n">Nn</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">psf_intermed</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">hi</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">hi</span><span class="p">]</span>    
    <span class="n">psf_corr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">hi</span><span class="p">,</span> <span class="n">hi</span><span class="p">:</span><span class="n">Nn</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">psf_intermed</span><span class="p">[</span><span class="n">lo</span><span class="p">:</span><span class="n">bigsz</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">hi</span><span class="p">]</span>        
    
    <span class="n">psf_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">psf_corr</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">psf_corr</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psf_corr</span><span class="p">)</span></div>



<div class="viewcode-block" id="ferengi_clip_edge">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.ferengi_clip_edge">[docs]</a>
<span class="k">def</span> <span class="nf">ferengi_clip_edge</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">auto_frac</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">clip_also</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dynamically clip the edges of an image based on standard deviation analysis.</span>

<span class="sd">    This function removes noisy or irrelevant border pixels by analyzing the </span>
<span class="sd">    standard deviation of pixel values in concentric rings centered on the image. </span>
<span class="sd">    Optionally, it can normalize the clipped image and apply the same clipping </span>
<span class="sd">    to a secondary array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        Input 2D image array.</span>
<span class="sd">    auto_frac : int, optional</span>
<span class="sd">        Initial fraction to define the size of concentric rings for analysis.</span>
<span class="sd">        Default is 2.</span>
<span class="sd">    clip_also : ndarray, optional</span>
<span class="sd">        Secondary array to apply the same clipping. Must have the same shape as `image`.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    norm : bool, optional</span>
<span class="sd">        If True, normalizes the clipped image and `clip_also` (if provided) by </span>
<span class="sd">        dividing each by its sum. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Number of pixels clipped from each side of the image.</span>
<span class="sd">    ndarray</span>
<span class="sd">        Clipped and optionally normalized image.</span>
<span class="sd">    ndarray, optional</span>
<span class="sd">        Clipped and optionally normalized secondary array (`clip_also`), if provided.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The clipping is based on detecting significant deviations (≥10 standard deviations) </span>
<span class="sd">      in the pixel values of the concentric rings.</span>
<span class="sd">    - If the number of significant deviations exceeds three times the rejected outliers,</span>
<span class="sd">      a warning is printed (&quot;Large gap?&quot;).</span>
<span class="sd">    - The function assumes the input image is a 2D array.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `clip_also` does not have the same shape as `image`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">rx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">auto_frac</span><span class="p">)</span>
    <span class="n">ry</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">M</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">auto_frac</span><span class="p">)</span>
    
    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">edge_index</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">med</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">nrej</span> <span class="o">=</span> <span class="n">resistent_mean</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">sigma</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">nrej</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rx</span><span class="p">)</span>
        <span class="n">rx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ry</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="n">new_med</span><span class="p">,</span> <span class="n">new_sig</span><span class="p">,</span> <span class="n">new_nrej</span> <span class="o">=</span> <span class="n">resistent_mean</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">new_sig</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">new_nrej</span><span class="p">)</span>
    
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sig</span> <span class="o">&gt;=</span> <span class="n">new_med</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">new_sig</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">lim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">new_nrej</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Large gap?&#39;</span><span class="p">)</span>
        <span class="n">npix</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">lim</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">clip_also</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clip_also</span> <span class="o">=</span> <span class="n">clip_also</span><span class="p">[</span><span class="n">npix</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">npix</span><span class="p">,</span> <span class="n">npix</span><span class="p">:</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">npix</span><span class="p">]</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">npix</span><span class="p">:</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">npix</span><span class="p">,</span> <span class="n">npix</span><span class="p">:</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">npix</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">clip_also</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clip_also</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">clip_also</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">clip_also</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">npix</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">clip_also</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">npix</span><span class="p">,</span> <span class="n">image</span></div>

    

<div class="viewcode-block" id="rebin2d">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.rebin2d">[docs]</a>
<span class="k">def</span> <span class="nf">rebin2d</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">Nout</span><span class="p">,</span> <span class="n">Mout</span><span class="p">,</span> <span class="n">flux_scale</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rebin a 2D image to a new shape with non-integer magnification.</span>

<span class="sd">    This function reduces or enlarges a 2D image to the specified output shape</span>
<span class="sd">    `(Nout, Mout)`, preserving flux or pixel values depending on the `flux_scale`</span>
<span class="sd">    parameter. The implementation is based on the FREBIN function from IDL Astrolib.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : ndarray</span>
<span class="sd">        Input 2D array representing the image.</span>
<span class="sd">    Nout : int</span>
<span class="sd">        Number of rows in the output array.</span>
<span class="sd">    Mout : int</span>
<span class="sd">        Number of columns in the output array.</span>
<span class="sd">    flux_scale : bool, optional</span>
<span class="sd">        If True, scales pixel values to conserve total flux.</span>
<span class="sd">        If False, normalizes pixel values by the scaling factor. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Rebinned 2D array with shape `(Nout, Mout)`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the input image shape is incompatible with the specified output shape.</span>

<span class="sd">    Warnings</span>
<span class="sd">    --------</span>
<span class="sd">    RuntimeWarning</span>
<span class="sd">        May be raised during calculations for empty slices or divisions by zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">xbox</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">Nout</span><span class="p">)</span>
    <span class="n">ybox</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">Mout</span><span class="p">)</span>

    <span class="n">temp_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="n">Mout</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Mout</span><span class="p">):</span>
        <span class="n">rstart</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ybox</span>
        <span class="n">istart</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rstart</span><span class="p">)</span>

        <span class="n">rstop</span> <span class="o">=</span> <span class="n">rstart</span> <span class="o">+</span> <span class="n">ybox</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">rstop</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rstop</span><span class="p">)</span>

        <span class="n">frac1</span> <span class="o">=</span> <span class="n">rstart</span> <span class="o">-</span> <span class="n">istart</span>
        <span class="n">frac2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">rstop</span> <span class="o">-</span> <span class="n">istop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">istart</span> <span class="o">==</span> <span class="n">istop</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="n">temp_y</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">frac1</span> <span class="o">-</span> <span class="n">frac2</span><span class="p">)</span> <span class="o">*</span> <span class="n">img</span><span class="p">[:,</span> <span class="n">istart</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="n">temp_y</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">img</span><span class="p">[:,</span> <span class="n">istart</span><span class="p">:</span><span class="n">istop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="o">-</span> <span class="n">frac1</span> <span class="o">*</span> <span class="n">img</span><span class="p">[:,</span> <span class="n">istart</span><span class="p">]</span>
                    <span class="o">-</span> <span class="n">frac2</span> <span class="o">*</span> <span class="n">img</span><span class="p">[:,</span> <span class="n">istop</span><span class="p">]</span>
                <span class="p">)</span>

    <span class="n">temp_y</span> <span class="o">=</span> <span class="n">temp_y</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">img_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">Mout</span><span class="p">,</span> <span class="n">Nout</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nout</span><span class="p">):</span>
        <span class="n">rstart</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">xbox</span>
        <span class="n">istart</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rstart</span><span class="p">)</span>

        <span class="n">rstop</span> <span class="o">=</span> <span class="n">rstart</span> <span class="o">+</span> <span class="n">xbox</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">rstop</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">istop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rstop</span><span class="p">)</span>

        <span class="n">frac1</span> <span class="o">=</span> <span class="n">rstart</span> <span class="o">-</span> <span class="n">istart</span>
        <span class="n">frac2</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">rstop</span> <span class="o">-</span> <span class="n">istop</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">istart</span> <span class="o">==</span> <span class="n">istop</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="n">img_bin</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">frac1</span> <span class="o">-</span> <span class="n">frac2</span><span class="p">)</span> <span class="o">*</span> <span class="n">temp_y</span><span class="p">[:,</span> <span class="n">istart</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="n">img_bin</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp_y</span><span class="p">[:,</span> <span class="n">istart</span><span class="p">:</span><span class="n">istop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="o">-</span> <span class="n">frac1</span> <span class="o">*</span> <span class="n">temp_y</span><span class="p">[:,</span> <span class="n">istart</span><span class="p">]</span>
                    <span class="o">-</span> <span class="n">frac2</span> <span class="o">*</span> <span class="n">temp_y</span><span class="p">[:,</span> <span class="n">istop</span><span class="p">]</span>
                <span class="p">)</span>

    <span class="k">if</span> <span class="n">flux_scale</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">img_bin</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">img_bin</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">xbox</span> <span class="o">*</span> <span class="n">ybox</span><span class="p">)</span></div>

        
        
<div class="viewcode-block" id="lum_evolution">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.lum_evolution">[docs]</a>
<span class="k">def</span> <span class="nf">lum_evolution</span><span class="p">(</span><span class="n">zlow</span><span class="p">,</span> <span class="n">zhigh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the luminosity evolution factor between two redshifts.</span>

<span class="sd">    This function computes the ratio of luminosities at two redshifts (`zhigh` and `zlow`)</span>
<span class="sd">    using the luminosity evolution model from Sobral et al. (2013).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    zlow : float</span>
<span class="sd">        Lower redshift value.</span>
<span class="sd">    zhigh : float</span>
<span class="sd">        Higher redshift value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The luminosity evolution factor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">luminosity</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">logL</span> <span class="o">=</span> <span class="mf">0.45</span> <span class="o">*</span> <span class="n">z</span> <span class="o">+</span> <span class="mf">41.87</span>
        <span class="k">return</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">logL</span>
    <span class="k">return</span> <span class="n">luminosity</span><span class="p">(</span><span class="n">zhigh</span><span class="p">)</span> <span class="o">/</span> <span class="n">luminosity</span><span class="p">(</span><span class="n">zlow</span><span class="p">)</span></div>



<div class="viewcode-block" id="ferengi_downscale">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.ferengi_downscale">[docs]</a>
<span class="k">def</span> <span class="nf">ferengi_downscale</span><span class="p">(</span><span class="n">image_low</span><span class="p">,</span> <span class="n">z_low</span><span class="p">,</span> <span class="n">z_high</span><span class="p">,</span> <span class="n">pix_low</span><span class="p">,</span> <span class="n">pix_hi</span><span class="p">,</span> <span class="n">upscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nofluxscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">evo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Downscale an image to simulate a higher redshift.</span>

<span class="sd">    This function adjusts the size, flux, and luminosity of an input image</span>
<span class="sd">    to simulate how it would appear at a higher redshift. The scaling factors</span>
<span class="sd">    are calculated based on angular and luminosity distances, pixel scales,</span>
<span class="sd">    and optional evolutionary corrections.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image_low : ndarray</span>
<span class="sd">        Input 2D image at the lower redshift.</span>
<span class="sd">    z_low : float</span>
<span class="sd">        Redshift of the input image.</span>
<span class="sd">    z_high : float</span>
<span class="sd">        Target redshift for the simulation.</span>
<span class="sd">    pix_low : float</span>
<span class="sd">        Pixel scale of the input image (arcsec/pixel) at the lower redshift.</span>
<span class="sd">    pix_hi : float</span>
<span class="sd">        Pixel scale of the output image (arcsec/pixel) at the higher redshift.</span>
<span class="sd">    upscale : bool, optional</span>
<span class="sd">        If True, inverts the scaling to simulate an image at a lower redshift.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    nofluxscale : bool, optional</span>
<span class="sd">        If True, skips flux scaling. Default is False.</span>
<span class="sd">    evo : float, optional</span>
<span class="sd">        Evolutionary correction factor to adjust for luminosity changes with redshift.</span>
<span class="sd">        If provided, the luminosity scaling is computed using:</span>
<span class="sd">            `evo_fact = 10 ** (-0.4 * evo * z_high)`.</span>
<span class="sd">        If None, the Sobral et al. (2013) luminosity evolution model is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        The adjusted 2D image at the target redshift.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - If `nofluxscale` is True, the flux scaling is skipped, and the image</span>
<span class="sd">      retains its original flux.</span>
<span class="sd">    - Uses the `rebin2d` function to scale the image dimensions while conserving flux.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the input image shape is invalid or scaling factors result in unrealistic dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">da_in</span> <span class="o">=</span> <span class="n">cosmos</span><span class="o">.</span><span class="n">angular_distance</span><span class="p">(</span><span class="n">z_low</span><span class="p">)</span>
    <span class="n">da_out</span> <span class="o">=</span> <span class="n">cosmos</span><span class="o">.</span><span class="n">angular_distance</span><span class="p">(</span><span class="n">z_high</span><span class="p">)</span>

    <span class="n">dl_in</span> <span class="o">=</span> <span class="n">cosmos</span><span class="o">.</span><span class="n">luminosity_distance</span><span class="p">(</span><span class="n">z_low</span><span class="p">)</span>
    <span class="n">dl_out</span> <span class="o">=</span> <span class="n">cosmos</span><span class="o">.</span><span class="n">luminosity_distance</span><span class="p">(</span><span class="n">z_high</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">evo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">evo_fact</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.4</span> <span class="o">*</span> <span class="n">evo</span> <span class="o">*</span> <span class="n">z_high</span><span class="p">)</span> <span class="c1"># UPDATED TO MATCH FERENGI ALGORITHM</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">evo_fact</span> <span class="o">=</span> <span class="n">lum_evolution</span><span class="p">(</span><span class="n">z_low</span><span class="p">,</span> <span class="n">z_high</span><span class="p">)</span>

    <span class="n">mag_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">da_in</span> <span class="o">/</span> <span class="n">da_out</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pix_low</span> <span class="o">/</span> <span class="n">pix_hi</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">upscale</span><span class="p">:</span>
        <span class="n">mag_factor</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">mag_factor</span>

    <span class="c1">#  lum_factor = (dl_in/dl_out)**2</span>
    <span class="n">lum_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">dl_in</span> <span class="o">/</span> <span class="n">dl_out</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">z_high</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">z_low</span><span class="p">)</span> <span class="c1">### UPDATED TO MATCH FERENGI ALGORITHM</span>

    <span class="k">if</span> <span class="n">nofluxscale</span><span class="p">:</span>
        <span class="n">lum_factor</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lum_factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">da_in</span> <span class="o">/</span> <span class="n">da_out</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">image_low</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">N_out</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">mag_factor</span><span class="p">))</span>
    <span class="n">M_out</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">M</span> <span class="o">*</span> <span class="n">mag_factor</span><span class="p">))</span>

    <span class="n">img_out</span> <span class="o">=</span> <span class="n">rebin2d</span><span class="p">(</span><span class="n">image_low</span><span class="p">,</span> <span class="n">N_out</span><span class="p">,</span> <span class="n">M_out</span><span class="p">,</span> <span class="n">flux_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">lum_factor</span> <span class="o">*</span> <span class="n">evo_fact</span>

    <span class="k">return</span> <span class="n">img_out</span></div>



<div class="viewcode-block" id="ferengi_odd_n_square">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.ferengi_odd_n_square">[docs]</a>
<span class="k">def</span> <span class="nf">ferengi_odd_n_square</span><span class="p">():</span>
    <span class="c1">#TBD : in principle avoidable if PSF already square image</span>
    <span class="c1">#feregi_psf_centre already includes number of odd pixels</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;In principle avoidable if PSF already square image&#39;</span><span class="p">)</span>
    <span class="k">return</span></div>



<div class="viewcode-block" id="ferengi_transformation_psf">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.ferengi_transformation_psf">[docs]</a>
<span class="k">def</span> <span class="nf">ferengi_transformation_psf</span><span class="p">(</span><span class="n">psf_low</span><span class="p">,</span> <span class="n">psf_high</span><span class="p">,</span> <span class="n">z_low</span><span class="p">,</span> <span class="n">z_high</span><span class="p">,</span> <span class="n">pix_low</span><span class="p">,</span> <span class="n">pix_high</span><span class="p">,</span> <span class="n">same_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the transformation PSF between two redshifts.</span>

<span class="sd">    This function calculates the transformation PSF that maps a low-redshift</span>
<span class="sd">    PSF (`psf_low`) to a high-redshift PSF (`psf_high`). It uses the angular</span>
<span class="sd">    distances, pixel scales, and redshift values to perform the necessary adjustments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psf_low : ndarray</span>
<span class="sd">        PSF at the lower redshift.</span>
<span class="sd">    psf_high : ndarray</span>
<span class="sd">        PSF at the higher redshift.</span>
<span class="sd">    z_low : float</span>
<span class="sd">        Redshift of the low-redshift PSF.</span>
<span class="sd">    z_high : float</span>
<span class="sd">        Redshift of the high-redshift PSF.</span>
<span class="sd">    pix_low : float</span>
<span class="sd">        Pixel scale of the low-redshift PSF (arcsec/pixel).</span>
<span class="sd">    pix_high : float</span>
<span class="sd">        Pixel scale of the high-redshift PSF (arcsec/pixel).</span>
<span class="sd">    same_size : bool, optional</span>
<span class="sd">        If True, ensures that the output PSFs have the same dimensions. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple of ndarray</span>
<span class="sd">        - The adjusted low-redshift PSF.</span>
<span class="sd">        - The adjusted high-redshift PSF.</span>
<span class="sd">        - The transformation PSF mapping `psf_low` to `psf_high`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function ensures that the PSFs are centered and normalized.</span>
<span class="sd">    - If the output PSF dimensions are even, additional padding is applied to ensure odd dimensions.</span>
<span class="sd">    - The transformation PSF is calculated using the `ferengi_deconvolve` function.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the PSF adjustment exceeds three times the original PSF size.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Center the input PSFs to ensure proper alignment</span>
    <span class="n">psf_l</span> <span class="o">=</span> <span class="n">ferengi_psf_centre</span><span class="p">(</span><span class="n">psf_low</span><span class="p">)</span>
    <span class="n">psf_h</span> <span class="o">=</span> <span class="n">ferengi_psf_centre</span><span class="p">(</span><span class="n">psf_high</span><span class="p">)</span>

    <span class="c1"># Calculate angular distances for redshift scaling</span>
    <span class="n">da_in</span> <span class="o">=</span> <span class="n">cosmos</span><span class="o">.</span><span class="n">angular_distance</span><span class="p">(</span><span class="n">z_low</span><span class="p">)</span>
    <span class="n">da_out</span> <span class="o">=</span> <span class="n">cosmos</span><span class="o">.</span><span class="n">angular_distance</span><span class="p">(</span><span class="n">z_high</span><span class="p">)</span>

    <span class="c1"># Initialize dimensions and padding for even-sized PSFs</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">psf_l</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">add</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">out_size</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">da_in</span> <span class="o">/</span> <span class="n">da_out</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pix_low</span> <span class="o">/</span> <span class="n">pix_high</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">add</span><span class="p">))</span>
    
    <span class="c1"># Ensure the output PSF has odd dimensions by adding padding as needed</span>
    <span class="k">while</span> <span class="n">out_size</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">add</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">psf_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">psf_l</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
        <span class="n">out_size</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">da_in</span> <span class="o">/</span> <span class="n">da_out</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pix_low</span> <span class="o">/</span> <span class="n">pix_high</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">add</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">add</span> <span class="o">&gt;</span> <span class="n">N</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;PSF adjustment exceeded acceptable limits.&quot;</span><span class="p">)</span>

    <span class="c1"># Downscale the low-redshift PSF to match the higher redshift</span>
    <span class="n">psf_l</span> <span class="o">=</span> <span class="n">ferengi_downscale</span><span class="p">(</span><span class="n">psf_l</span><span class="p">,</span> <span class="n">z_low</span><span class="p">,</span> <span class="n">z_high</span><span class="p">,</span> <span class="n">pix_low</span><span class="p">,</span> <span class="n">pix_high</span><span class="p">,</span> <span class="n">nofluxscale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">psf_l</span> <span class="o">=</span> <span class="n">ferengi_psf_centre</span><span class="p">(</span><span class="n">psf_l</span><span class="p">)</span>

    <span class="c1"># Ensure both PSFs have the same dimensions</span>
    <span class="n">psf_l</span><span class="p">,</span> <span class="n">psf_h</span> <span class="o">=</span> <span class="n">ferengi_make_psf_same</span><span class="p">(</span><span class="n">psf_l</span><span class="p">,</span> <span class="n">psf_h</span><span class="p">)</span>

    <span class="c1"># Center and normalize the PSFs</span>
    <span class="n">psf_l</span> <span class="o">=</span> <span class="n">ferengi_psf_centre</span><span class="p">(</span><span class="n">psf_l</span><span class="p">)</span>
    <span class="n">psf_h</span> <span class="o">=</span> <span class="n">ferengi_psf_centre</span><span class="p">(</span><span class="n">psf_h</span><span class="p">)</span>

    <span class="n">psf_l</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psf_l</span><span class="p">)</span>
    <span class="n">psf_h</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psf_h</span><span class="p">)</span>

    <span class="c1"># Compute the transformation PSF</span>
    <span class="n">transformation_psf</span> <span class="o">=</span> <span class="n">ferengi_psf_centre</span><span class="p">(</span><span class="n">ferengi_deconvolve</span><span class="p">(</span><span class="n">psf_h</span><span class="p">,</span> <span class="n">psf_l</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">psf_l</span><span class="p">,</span> <span class="n">psf_h</span><span class="p">,</span> <span class="n">transformation_psf</span></div>


<div class="viewcode-block" id="ferengi_convolve_plus_noise">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.ferengi_convolve_plus_noise">[docs]</a>
<span class="k">def</span> <span class="nf">ferengi_convolve_plus_noise</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="n">sky</span><span class="p">,</span> <span class="n">exptime</span><span class="p">,</span> <span class="n">nonoise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">border_clip</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve an image with a PSF and optionally add noise.</span>

<span class="sd">    This function convolves the input image with a Point Spread Function (PSF)</span>
<span class="sd">    in the Fourier domain. Optionally, it adds noise based on the provided</span>
<span class="sd">    sky background and exposure time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        Input 2D array representing the image.</span>
<span class="sd">    psf : ndarray</span>
<span class="sd">        Point Spread Function (PSF) to convolve with the image.</span>
<span class="sd">    sky : ndarray</span>
<span class="sd">        2D array representing the sky background.</span>
<span class="sd">    exptime : float</span>
<span class="sd">        Exposure time used to calculate noise levels.</span>
<span class="sd">    nonoise : bool, optional</span>
<span class="sd">        If True, skips adding noise. Default is False.</span>
<span class="sd">    border_clip : int, optional</span>
<span class="sd">        Number of pixels to clip from the borders of the PSF. Default is None.</span>
<span class="sd">    extend : bool, optional</span>
<span class="sd">        If True, keeps the extended image dimensions after convolution.</span>
<span class="sd">        If False, crops the image to its original size. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        Convolved image, optionally with added noise.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the dimensions of the sky background are insufficient for the output image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Clip PSF borders if specified</span>
    <span class="k">if</span> <span class="n">border_clip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">Npsf</span><span class="p">,</span> <span class="n">Mpsf</span> <span class="o">=</span> <span class="n">psf</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">psf</span> <span class="o">=</span> <span class="n">psf</span><span class="p">[</span><span class="n">border_clip</span><span class="p">:</span><span class="n">Npsf</span><span class="o">-</span><span class="n">border_clip</span><span class="p">,</span> <span class="n">border_clip</span><span class="p">:</span><span class="n">Mpsf</span><span class="o">-</span><span class="n">border_clip</span><span class="p">]</span>
    
    <span class="c1"># Get the new PSF dimensions after clipping</span>
    <span class="n">Npsf</span><span class="p">,</span> <span class="n">Mpsf</span> <span class="o">=</span> <span class="n">psf</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">Nimg</span><span class="p">,</span> <span class="n">Mimg</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Pad the input image to match the PSF size for convolution</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">Npsf</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
    
    <span class="c1"># Perform convolution in the Fourier domain with a normalized PSF</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">apcon</span><span class="o">.</span><span class="n">convolve_fft</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">psf</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psf</span><span class="p">))</span>
    
    <span class="c1"># Adjust the output image dimensions</span>
    <span class="n">Nout</span><span class="p">,</span> <span class="n">Mout</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">extend</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">Npsf</span><span class="p">:</span><span class="n">Nout</span><span class="o">-</span><span class="n">Npsf</span><span class="p">,</span> <span class="n">Mpsf</span><span class="p">:</span><span class="n">Mout</span><span class="o">-</span><span class="n">Mpsf</span><span class="p">]</span>
        
    <span class="c1"># Update output dimensions after cropping</span>
    <span class="n">Nout</span><span class="p">,</span> <span class="n">Mout</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">Nsky</span><span class="p">,</span> <span class="n">Msky</span> <span class="o">=</span> <span class="n">sky</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">nonoise</span><span class="p">:</span>
        <span class="c1"># Calculate effective noise padding</span>
        <span class="n">ef</span> <span class="o">=</span> <span class="n">Nout</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Add noise based on the sky background and exposure time</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">sky</span><span class="p">[</span><span class="n">Nsky</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="n">Nout</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span><span class="n">Nsky</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Nout</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ef</span><span class="p">,</span> <span class="n">Msky</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="n">Mout</span><span class="o">//</span><span class="mi">2</span><span class="p">:</span><span class="n">Msky</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Mout</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ef</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">out</span> <span class="o">*</span> <span class="n">exptime</span><span class="p">))</span> <span class="o">*</span> <span class="n">npr</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="n">exptime</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># Return an error matrix if the sky background dimensions are insufficient</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">99</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="dump_results">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.dump_results">[docs]</a>
<span class="k">def</span> <span class="nf">dump_results</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="n">imgname_in</span><span class="p">,</span> <span class="n">bgimage_in</span><span class="p">,</span> <span class="n">names_out</span><span class="p">,</span> <span class="n">lowz_info</span><span class="p">,</span> <span class="n">highz_info</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save processed image and PSF to FITS files with metadata.</span>

<span class="sd">    This function writes the processed image and its associated PSF to separate</span>
<span class="sd">    FITS files. The header of the image file is populated with metadata about</span>
<span class="sd">    the input parameters, including low- and high-redshift information.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : ndarray</span>
<span class="sd">        Processed 2D image to save.</span>
<span class="sd">    psf : ndarray</span>
<span class="sd">        PSF associated with the processed image.</span>
<span class="sd">    imgname_in : str or list of str</span>
<span class="sd">        Input image file name(s).</span>
<span class="sd">    bgimage_in : str or list of str</span>
<span class="sd">        Background image file name(s).</span>
<span class="sd">    names_out : tuple of str</span>
<span class="sd">        Output file names for the image and PSF, in the format `(image_out, psf_out)`.</span>
<span class="sd">    lowz_info : dict</span>
<span class="sd">        Dictionary of parameters for the low-redshift input, including PSF, pixel scale,</span>
<span class="sd">        and other related information.</span>
<span class="sd">    highz_info : dict</span>
<span class="sd">        Dictionary of parameters for the high-redshift input, including PSF, pixel scale,</span>
<span class="sd">        and other related information.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name_imout</span><span class="p">,</span> <span class="n">name_psfout</span> <span class="o">=</span> <span class="n">names_out</span>
    
    <span class="n">Hprim</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
    <span class="n">hdu</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span><span class="n">Hprim</span><span class="p">])</span>
    <span class="n">hdr_img</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    
    <span class="c1"># Utility function to add multi-entry parameters as separate numbered columns</span>
    <span class="k">def</span> <span class="nf">add_multi_entry</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">base_key</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">enumerate_single</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">enumerate_single</span><span class="p">:</span>  <span class="c1"># No enumeration if only one element and enumerate_single is False</span>
                <span class="n">header</span><span class="p">[</span><span class="n">base_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">description</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># Shorten base_key to 6 characters to keep within 8-character limit when adding &quot;_i&quot; suffix</span>
                    <span class="n">header</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_key</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">description</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">header</span><span class="p">[</span><span class="n">base_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">description</span><span class="p">)</span>

    <span class="c1"># Convert input image names and background image names to filenames only</span>
    <span class="n">imgname_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">imgname_in</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imgname_in</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">imgname_in</span><span class="p">))]</span>
    <span class="n">bgimage_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">bgimage_in</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bgimage_in</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">bgimage_in</span><span class="p">))]</span>

    <span class="c1"># Add each entry as separate columns</span>
    <span class="n">add_multi_entry</span><span class="p">(</span><span class="n">hdr_img</span><span class="p">,</span> <span class="s1">&#39;INPUT&#39;</span><span class="p">,</span> <span class="n">imgname_list</span><span class="p">,</span> <span class="s1">&#39;Input image&#39;</span><span class="p">)</span>
    <span class="n">add_multi_entry</span><span class="p">(</span><span class="n">hdr_img</span><span class="p">,</span> <span class="s1">&#39;SKYIM&#39;</span><span class="p">,</span> <span class="n">bgimage_list</span><span class="p">,</span> <span class="s1">&#39;Background image&#39;</span><span class="p">)</span>  <span class="c1"># Changed &#39;SKY_IMG&#39; to &#39;SKYIM&#39;</span>

    <span class="c1"># Process low-z information with multi-column handling and enumeration for all lists</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">lowz_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">base_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_I&quot;</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;psf&quot;</span><span class="p">:</span>
            <span class="n">value_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value_list</span> <span class="o">=</span> <span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="n">add_multi_entry</span><span class="p">(</span><span class="n">hdr_img</span><span class="p">,</span> <span class="n">base_key</span><span class="p">,</span> <span class="n">value_list</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> input lowz&quot;</span><span class="p">,</span> <span class="n">enumerate_single</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">hdr_img</span><span class="p">[</span><span class="s1">&#39;comment&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Using ferengi.py version </span><span class="si">{</span><span class="n">version</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="c1"># Process high-z information, avoiding enumeration if there’s a single value in lists</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">highz_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">base_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">_O&quot;</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;psf&quot;</span><span class="p">:</span>
            <span class="n">value_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value_list</span> <span class="o">=</span> <span class="n">value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="c1"># For high-z info, set enumerate_single=False to avoid suffix if there&#39;s a single value</span>
        <span class="n">add_multi_entry</span><span class="p">(</span><span class="n">hdr_img</span><span class="p">,</span> <span class="n">base_key</span><span class="p">,</span> <span class="n">value_list</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> input highz&quot;</span><span class="p">,</span> <span class="n">enumerate_single</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="c1"># Write the image and PSF to files</span>
    <span class="n">hdu</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">name_imout</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pyfits</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">name_psfout</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span></div>



<div class="viewcode-block" id="kcorrect_maggies">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.kcorrect_maggies">[docs]</a>
<span class="k">def</span> <span class="nf">kcorrect_maggies</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">im_err</span><span class="p">,</span> <span class="n">lowz_info</span><span class="p">,</span> <span class="n">highz_info</span><span class="p">,</span> <span class="n">lambda_lo</span><span class="p">,</span> <span class="n">lambda_hi</span><span class="p">,</span> <span class="n">err0_mag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">evo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noflux</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kc_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform K-correction on multi-band images.</span>

<span class="sd">    This function applies K-corrections to images observed in multiple bands,</span>
<span class="sd">    adjusting fluxes and errors to account for redshift differences and instrumental</span>
<span class="sd">    characteristics.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : list of ndarray</span>
<span class="sd">        List of 2D images for each observed band.</span>
<span class="sd">    im_err : list of ndarray</span>
<span class="sd">        List of 2D error maps corresponding to `image`.</span>
<span class="sd">    lowz_info : dict</span>
<span class="sd">        Dictionary containing information about the low-redshift input (e.g., redshift,</span>
<span class="sd">        pixel scale, exposure time, zero-point magnitudes).</span>
<span class="sd">    highz_info : dict</span>
<span class="sd">        Dictionary containing information about the high-redshift input.</span>
<span class="sd">    lambda_lo : array-like</span>
<span class="sd">        Central wavelengths of the filters at low redshift.</span>
<span class="sd">    lambda_hi : array-like</span>
<span class="sd">        Central wavelengths of the filters at high redshift.</span>
<span class="sd">    err0_mag : float, optional</span>
<span class="sd">        Minimum magnitude error for all bands. Default is None.</span>
<span class="sd">    evo : float, optional</span>
<span class="sd">        Evolutionary correction factor. Default is None.</span>
<span class="sd">    noflux : bool, optional</span>
<span class="sd">        If True, skips flux scaling. Default is None.</span>
<span class="sd">    kc_obj : object, optional</span>
<span class="sd">        Pre-initialized K-correction object. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        - Corrected image(s) adjusted for redshift differences.</span>
<span class="sd">        - Background image adjusted for redshift.</span>
<span class="sd">    &quot;&quot;&quot;</span>
   <span class="c1"># Number of bands in the input data</span>
    <span class="n">n_bands</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

    <span class="c1"># Calculate the relative difference in filter wavelengths to find the closest match</span>
    <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_hi</span> <span class="o">/</span> <span class="n">lambda_lo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">idx_bestfilt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>

    <span class="c1"># Determine weights for the closest filters in rest-frame</span>
    <span class="n">dz1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_hi</span> <span class="o">-</span> <span class="n">lambda_lo</span><span class="p">)</span>
    <span class="nb">ord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dz1</span><span class="p">)</span>  <span class="c1"># Indices of filters sorted by proximity</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_bands</span><span class="p">)</span>  <span class="c1"># Default weight for all bands</span>

    <span class="c1"># Assign weights based on the number of bands and proximity of filters</span>
    <span class="k">if</span> <span class="n">dz1</span><span class="p">[</span><span class="nb">ord</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_bands</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">weight</span><span class="p">[</span><span class="nb">ord</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">n_bands</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">weight</span><span class="p">[</span><span class="nb">ord</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">n_bands</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">weight</span><span class="p">[</span><span class="nb">ord</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_bands</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_bands</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">weight</span><span class="p">[</span><span class="nb">ord</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">n_bands</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">n_bands</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">weight</span><span class="p">[</span><span class="nb">ord</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_bands</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n_bands</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">weight</span><span class="p">[</span><span class="nb">ord</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_bands</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Lists to store downscaled images and error maps</span>
    <span class="n">img_downscale</span> <span class="p">,</span> <span class="n">imerr_downscale</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bands</span><span class="p">):</span>
        <span class="c1"># Downscale the image and error map to match the high redshift</span>
        <span class="n">img_downscale</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ferengi_downscale</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">],</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">],</span> <span class="n">evo</span><span class="o">=</span><span class="n">evo</span><span class="p">,</span> <span class="n">nofluxscale</span><span class="o">=</span><span class="n">noflux</span><span class="p">))</span>
        <span class="n">img_downscale</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">ring_sky</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">nw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Subtract sky background</span>

        <span class="n">imerr_downscale</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ferengi_downscale</span><span class="p">(</span><span class="n">im_err</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">],</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">],</span> <span class="n">evo</span><span class="o">=</span><span class="n">evo</span><span class="p">,</span> <span class="n">nofluxscale</span><span class="o">=</span><span class="n">noflux</span><span class="p">))</span>

        <span class="c1"># Convert errors from counts to magnitudes</span>
        <span class="n">imerr_downscale</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.5</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">imerr_downscale</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">img_downscale</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Convert flux from counts to maggies</span>
        <span class="n">img_downscale</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cts2maggies</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;zp&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Define the sigma threshold for K-correction</span>
    <span class="n">siglim</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bands</span><span class="p">)</span>  <span class="c1"># Array to store sigma values for each band</span>
    <span class="n">npix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># Number of pixels in a single band</span>

    <span class="c1"># Find the filter closest to the high redshift filter</span>
    <span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_hi</span> <span class="o">/</span> <span class="n">lambda_lo</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">])</span>
    <span class="n">filt_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">zmin</span><span class="p">)</span>

    <span class="c1"># Initialize sigma maps for each band and count of high-sigma pixels</span>
    <span class="n">nsig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">)</span>
    <span class="n">nhi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Create sigma maps and identify high-sigma pixels</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bands</span><span class="p">):</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">resistent_mean</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># Robust mean and sigma</span>
        <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">npix</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>  <span class="c1"># Adjusted sigma for the band</span>
        <span class="n">nsig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scndi</span><span class="o">.</span><span class="n">median_filter</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># Sigma map</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">nsig</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">siglim</span><span class="p">)</span>  <span class="c1"># High-sigma pixels</span>
        <span class="k">if</span> <span class="n">hi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nhi</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Increment count for high-sigma pixels</span>

    <span class="c1"># Select &quot;good&quot; pixels from the closest filter based on sigma range</span>
    <span class="n">good1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">nsig</span><span class="p">[</span><span class="n">filt_i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.25</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">nsig</span><span class="p">[</span><span class="n">filt_i</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">siglim</span><span class="p">))</span>

    <span class="c1"># Select 50% of pixels in the range 0.25 &lt; sigma &lt; siglim</span>
    <span class="k">if</span> <span class="n">good1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_selec</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">good1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">good1_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">good1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_selec</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">good1</span> <span class="o">=</span> <span class="p">(</span><span class="n">good1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">good1_indices</span><span class="p">],</span> <span class="n">good1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">good1_indices</span><span class="p">])</span>

    <span class="c1"># Select pixels based on high-sigma count across all bands</span>
    <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">nhi</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">nsig</span><span class="p">[</span><span class="n">filt_i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">siglim</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">good</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No filters have 3+ high sigma pixels&#39;</span><span class="p">)</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">nhi</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">nsig</span><span class="p">[</span><span class="n">filt_i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">siglim</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">good</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No filters have 2+ high sigma pixels&#39;</span><span class="p">)</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">nhi</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">nsig</span><span class="p">[</span><span class="n">filt_i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">siglim</span><span class="p">))</span>

    <span class="c1"># Combine indices of &quot;good&quot; pixels and remove duplicates</span>
    <span class="k">if</span> <span class="n">good1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">good</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">good</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">good1</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">good</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">good1</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
        <span class="n">combined_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">good</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">good</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">unique_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">combined_indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">good</span> <span class="o">=</span> <span class="p">(</span><span class="n">unique_indices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">unique_indices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Process &quot;good&quot; pixels if any are identified</span>
    <span class="n">ngood</span> <span class="o">=</span> <span class="n">good</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">ngood</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No pixels to process&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ngood</span><span class="si">}</span><span class="s1"> pixels to process&#39;</span><span class="p">)</span>

        <span class="n">maggies</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Flux in maggies for K-correction</span>
        <span class="n">err</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Error associated with each pixel</span>
        <span class="n">nsig_2d</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Sigma values for selected pixels</span>

        <span class="c1"># Extract values for K-correction</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngood</span><span class="p">):</span>
            <span class="n">aux_maggies</span><span class="p">,</span> <span class="n">aux_err</span><span class="p">,</span> <span class="n">aux_nsig</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bands</span><span class="p">):</span>
                <span class="n">aux_maggies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">good</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]][</span><span class="n">good</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]])</span>
                <span class="n">aux_err</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imerr_downscale</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">good</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]][</span><span class="n">good</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]])</span>
                <span class="n">aux_nsig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nsig</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">good</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]][</span><span class="n">good</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">maggies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">aux_maggies</span><span class="p">))</span>
            <span class="n">nsig_2d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">aux_nsig</span><span class="p">))</span>
            <span class="n">err</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">aux_err</span><span class="p">))</span>

        <span class="c1"># Handle infinite errors by setting them to a large value</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngood</span><span class="p">):</span>
            <span class="n">inf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">err</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">inf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">err</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">inf</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99999</span>
            <span class="n">err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">err</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">99999</span><span class="p">,</span> <span class="n">err</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">99999</span><span class="p">)</span>

        <span class="c1"># Create arrays for minimum errors and weights</span>
        <span class="n">err0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">err0_mag</span><span class="p">,</span> <span class="p">(</span><span class="n">ngood</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">wei</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="p">(</span><span class="n">ngood</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Combine minimum errors with calculated errors</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">err0</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">err</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">wei</span>

        <span class="c1"># Convert errors to inverse variance</span>
        <span class="n">ivar</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.5</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="n">err</span> <span class="o">/</span> <span class="n">maggies</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">inf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ivar</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">inf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ivar</span><span class="p">[</span><span class="n">inf</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ivar</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ivar</span><span class="p">)])</span>

        <span class="c1"># Setup K-correction object</span>
        <span class="n">responses_lo</span> <span class="o">=</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span>
        <span class="n">responses_hi</span> <span class="o">=</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span>
        <span class="n">redshift_lo</span> <span class="o">=</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ngood</span><span class="p">)</span>
        <span class="n">redshift_hi</span> <span class="o">=</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ngood</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kc_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Creating kcorrect object...&quot;</span><span class="p">)</span>
            <span class="n">cos</span> <span class="o">=</span> <span class="n">FlatLambdaCDM</span><span class="p">(</span><span class="n">H0</span><span class="o">=</span><span class="n">cosmos</span><span class="o">.</span><span class="n">H0</span><span class="p">,</span> <span class="n">Om0</span><span class="o">=</span><span class="n">cosmos</span><span class="o">.</span><span class="n">Omat</span><span class="p">,</span> <span class="n">Ob0</span><span class="o">=</span><span class="n">cosmos</span><span class="o">.</span><span class="n">Obar</span><span class="p">)</span>
            <span class="n">kc</span> <span class="o">=</span> <span class="n">kcorrect</span><span class="o">.</span><span class="n">kcorrect</span><span class="o">.</span><span class="n">Kcorrect</span><span class="p">(</span><span class="n">responses</span><span class="o">=</span><span class="n">responses_lo</span><span class="p">,</span> <span class="n">responses_out</span><span class="o">=</span><span class="p">[</span><span class="n">responses_hi</span><span class="p">],</span> <span class="n">responses_map</span><span class="o">=</span><span class="p">[</span><span class="n">responses_lo</span><span class="p">[</span><span class="n">idx_bestfilt</span><span class="p">]],</span> <span class="n">cosmo</span><span class="o">=</span><span class="n">cos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kc</span> <span class="o">=</span> <span class="n">kc_obj</span>

        <span class="c1"># Perform K-correction calculations</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">kc</span><span class="o">.</span><span class="n">fit_coeffs</span><span class="p">(</span><span class="n">redshift</span><span class="o">=</span><span class="n">redshift_lo</span><span class="p">,</span> <span class="n">maggies</span><span class="o">=</span><span class="n">maggies</span><span class="p">,</span> <span class="n">ivar</span><span class="o">=</span><span class="n">ivar</span><span class="p">)</span>

        <span class="c1"># Reconstruct magnitudes at the high redshift</span>
        <span class="n">r_maggies</span> <span class="o">=</span> <span class="n">kc</span><span class="o">.</span><span class="n">reconstruct_out</span><span class="p">(</span><span class="n">redshift</span><span class="o">=</span><span class="n">redshift_hi</span><span class="p">,</span> <span class="n">coeffs</span><span class="o">=</span><span class="n">coeffs</span><span class="p">)</span>

    <span class="c1"># Scale the background using the high redshift factor</span>
    <span class="n">bg</span> <span class="o">=</span> <span class="n">img_downscale</span><span class="p">[</span><span class="n">filt_i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">])</span>
    <span class="n">img_downscale</span> <span class="o">=</span> <span class="n">bg</span>

    <span class="c1"># Apply K-corrections to selected pixels</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">good</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">good</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">good</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">good</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngood</span><span class="p">):</span>
            <span class="n">img_downscale</span><span class="p">[</span><span class="n">good</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]][</span><span class="n">good</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">r_maggies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">])</span>

    <span class="c1"># Convert back to counts</span>
    <span class="n">img_downscale</span> <span class="o">=</span> <span class="n">maggies2cts</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">,</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;zp&#39;</span><span class="p">])</span>
    <span class="n">bg</span> <span class="o">=</span> <span class="n">maggies2cts</span><span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;zp&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">img_downscale</span><span class="p">,</span> <span class="n">bg</span></div>



<div class="viewcode-block" id="filer_list">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.filer_list">[docs]</a>
<span class="k">def</span> <span class="nf">filer_list</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve the list of available filters in the kcorrect package.</span>

<span class="sd">    This function returns a list of all the filters available in the</span>
<span class="sd">    `kcorrect` package. These filters are used for K-correction calculations</span>
<span class="sd">    and are pre-defined within the package.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of filter names available in the `kcorrect` package.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">kcorrect</span><span class="o">.</span><span class="n">response</span><span class="o">.</span><span class="n">all_responses</span><span class="p">()</span></div>



<div class="viewcode-block" id="ferengi">
<a class="viewcode-back" href="../../dopterian.html#dopterianPlus.dopterian.ferengi">[docs]</a>
<span class="k">def</span> <span class="nf">ferengi</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">lowz_info</span><span class="p">,</span> <span class="n">highz_info</span><span class="p">,</span> <span class="n">namesout</span><span class="p">,</span> <span class="n">imerr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">err0_mag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kc_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noflux</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">evo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minimum_output_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noconv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nonoise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_psf_FWHM</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">border_clip</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate galaxy redshifting with instrumental and cosmological effects.</span>

<span class="sd">    Simulates how galaxies would appear at higher redshifts, accounting for angular </span>
<span class="sd">    resolution degradation, surface brightness dimming, and wavelength shifts. The process </span>
<span class="sd">    integrates PSFs for both redshifts, photometric band adjustments, and optional evolutionary </span>
<span class="sd">    corrections to produce realistic observational conditions at the target redshift.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    images : list of str</span>
<span class="sd">        List of paths to the input images, one for each band. All files must be in FITS format and in units of [counts].</span>
<span class="sd">    background : list of str</span>
<span class="sd">        List of paths to the background sky images, one for each band. All files must be in FITS format and in units of [counts/sec].</span>
<span class="sd">    lowz_info : dict</span>
<span class="sd">        Dictionary containing information about the low-redshift input. Keys include:</span>

<span class="sd">        - &#39;redshift&#39;: float, redshift of the input images.</span>
<span class="sd">        - &#39;psf&#39;: list of str, paths to the PSFs for each band at low redshift (FITS format, normalized total flux to 1).</span>
<span class="sd">        - &#39;zp&#39;: list of float, zero-point magnitudes for each band [magnitudes].</span>
<span class="sd">        - &#39;exptime&#39;: list of float, exposure times for each band [seconds].</span>
<span class="sd">        - &#39;filter&#39;: list of str, names of the input filters for each band. Filters must exist in the `kcorrect` catalog.</span>
<span class="sd">        - &#39;pixscale&#39;: float, pixel scale of the images [arcseconds per pixel].</span>
<span class="sd">        - &#39;lambda&#39;: list of float, central wavelengths of the filters [angstroms].</span>
<span class="sd">    highz_info : dict</span>
<span class="sd">        Dictionary containing information about the high-redshift simulation. Keys include:</span>

<span class="sd">        - &#39;redshift&#39;: float, target redshift.</span>
<span class="sd">        - &#39;psf&#39;: str, path to the PSF file for the simulation (FITS format, normalized total flux to 1).</span>
<span class="sd">        - &#39;zp&#39;: float, zero-point magnitude [magnitudes].</span>
<span class="sd">        - &#39;exptime&#39;: float, exposure time [seconds].</span>
<span class="sd">        - &#39;filter&#39;: str, name of the output filter. Must exist in the `kcorrect` catalog.</span>
<span class="sd">        - &#39;pixscale&#39;: float, pixel scale of the simulation [arcseconds per pixel].</span>
<span class="sd">        - &#39;lambda&#39;: float, central wavelength of the output filter [angstroms].</span>
<span class="sd">    namesout : list of str</span>
<span class="sd">        Paths to the output files: [output_sci_image, output_psf_image]. The output will be in FITS format.</span>
<span class="sd">    imerr : list of str, optional</span>
<span class="sd">        List of paths to error maps for the input images (FITS format, in units of [counts]). Default is None, in which case</span>
<span class="sd">        error maps are generated from the square root of the input images.</span>
<span class="sd">    err0_mag : float, optional</span>
<span class="sd">        Minimum magnitude error for all bands [magnitudes]. Default is None.</span>
<span class="sd">    kc_obj : object, optional</span>
<span class="sd">        Pre-initialized K-correction object. If not provided, it will be created automatically.</span>
<span class="sd">    noflux : bool, optional</span>
<span class="sd">        If True, skips flux scaling. Default is False.</span>
<span class="sd">    evo : float, optional</span>
<span class="sd">        Evolutionary correction factor. Two models are used:</span>
<span class="sd">        </span>
<span class="sd">        - If `evo` is specified, it applies the equation:</span>
<span class="sd">          `evo_fact = 10 ** (-0.4 * evo * z_high)`</span>
<span class="sd">        - If `evo` is None, it uses the Sobral et al. (2013) luminosity evolution model.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    minimum_output_size : int, optional</span>
<span class="sd">        Minimum size (in pixels) for the output redshifted image. Default is None.</span>
<span class="sd">    noconv : bool, optional</span>
<span class="sd">        If True, skips convolution with the transformation PSF. Default is False.</span>
<span class="sd">    extend : bool, optional</span>
<span class="sd">        If True, keeps extended image dimensions after convolution. Default is False.</span>
<span class="sd">    nonoise : bool, optional</span>
<span class="sd">        If True, skips adding noise to the output image. Default is False.</span>
<span class="sd">    check_psf_FWHM : bool, optional</span>
<span class="sd">        If True, ensures the PSF at high redshift is broader than the low-redshift PSF.</span>
<span class="sd">        If the condition is not met, the simulation is not performed. Default is False.</span>
<span class="sd">    border_clip : int, optional</span>
<span class="sd">        Number of pixels to clip from the PSF borders before convolution. Default is 3.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        - ndarray: The redshifted and convolved image.</span>
<span class="sd">        - ndarray: The reconstructed PSF.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the input lists (images, background, or PSFs) have inconsistent lengths.</span>
<span class="sd">        If the input images have inconsistent shapes.</span>
<span class="sd">    ZeroDivisionError</span>
<span class="sd">        If an input image contains non-positive values, leading to division by zero during error calculation.</span>
<span class="sd">    RuntimeError</span>
<span class="sd">        If an unexpected error occurs during the simulation process.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the PSF enlargement process fails during convolution.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Filters specified in the `lowz_info` and `highz_info` dictionaries must be part of the catalog in the `kcorrect` package.</span>
<span class="sd">      Use the `filter_list` function from `dopterian` to view the available filters.</span>
<span class="sd">    - If the parameter `kc_obj` is not provided, dopterian will automatically create the K-correction object.</span>
<span class="sd">      However, for simulations involving large sets of galaxies using the same input and output filters,</span>
<span class="sd">      it is recommended to provide the K-correction object as a parameter to save computation time.</span>
<span class="sd">    - At least two input filters are required to apply the K-correction. If only one filter is provided, the correction is skipped.</span>

<span class="sd">    &quot;&quot;&quot;</span>
     <span class="c1"># Determine the number of input bands</span>
    <span class="n">n_bands</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

    <span class="c1"># Determine whether to apply K-correction based on the number of bands</span>
    <span class="n">apply_kcorrect</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">n_bands</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">False</span>

    <span class="c1"># Initialize lists for PSFs, sky backgrounds, images, and error maps</span>

    <span class="n">Pl</span><span class="p">,</span> <span class="n">Ph</span><span class="p">,</span> <span class="n">sky</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">im_err</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="c1"># Convert the wavelength information to NumPy arrays for calculations</span>
    <span class="k">if</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;lambda&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lambda_lo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;lambda&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;lambda&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lambda_hi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;lambda&#39;</span><span class="p">])</span>

    <span class="c1"># Load input images, PSFs, and background files</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bands</span><span class="p">):</span>
        <span class="n">image</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyfits</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">Pl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyfits</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;psf&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">sky</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyfits</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">background</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="c1"># Validate the consistency of input list lengths</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">background</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;psf&#39;</span><span class="p">])]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">length</span> <span class="o">==</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="n">lengths</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;All input lists must have the same number of entries&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">99</span><span class="p">,</span> <span class="o">-</span><span class="mi">99</span>

    <span class="c1"># Ensure all input images have the same shape</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">banda</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">banda</span> <span class="ow">in</span> <span class="n">image</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">shapes</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: All images must have the same shape&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">99</span><span class="p">,</span> <span class="o">-</span><span class="mi">99</span>

    <span class="c1"># Validate the size of the redshifted output image</span>
    <span class="k">if</span> <span class="n">minimum_output_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">predict_redshifted_image_size</span><span class="p">(</span><span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">],</span> <span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">minimum_output_size</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The size of the redshifted image is smaller than the minimum size. The simulation is not possible&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">99</span><span class="p">,</span> <span class="o">-</span><span class="mi">99</span>

    <span class="c1"># Load the high-redshift PSF</span>
    <span class="n">Ph</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyfits</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;psf&#39;</span><span class="p">]))</span>

    <span class="c1"># Create error maps if they are not provided</span>
    <span class="k">if</span> <span class="n">imerr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bands</span><span class="p">):</span>
            <span class="n">im_err</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>  <span class="c1"># Poisson noise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bands</span><span class="p">):</span>
            <span class="n">im_err</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyfits</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">imerr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="c1"># Determine scaling for images based on K-correction</span>
    <span class="k">if</span> <span class="n">apply_kcorrect</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># K-correction is not applied</span>
        <span class="n">img_nok</span> <span class="o">=</span> <span class="n">maggies2cts</span><span class="p">(</span><span class="n">cts2maggies</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">],</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;zp&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;zp&#39;</span><span class="p">])</span>
        <span class="n">psf_lo</span> <span class="o">=</span> <span class="n">Pl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">psf_hi</span> <span class="o">=</span> <span class="n">Ph</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Select the best matching PSF for output redshift</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_hi</span> <span class="o">/</span> <span class="n">lambda_lo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">idx_bestfilt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span>
        <span class="n">psf_lo</span> <span class="o">=</span> <span class="n">Pl</span><span class="p">[</span><span class="n">idx_bestfilt</span><span class="p">]</span>
        <span class="n">psf_hi</span> <span class="o">=</span> <span class="n">Ph</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Verify that the high-redshift PSF is broader than the low-redshift PSF</span>
    <span class="k">if</span> <span class="n">check_psf_FWHM</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">check_PSF_FWHM</span><span class="p">(</span><span class="n">psf_lo</span><span class="p">,</span> <span class="n">psf_hi</span><span class="p">,</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">],</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The FWHM of the redshifted PSF is broader than that of the high-z PSF. The simulation is not possible&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">99</span><span class="p">,</span> <span class="o">-</span><span class="mi">99</span>

    <span class="c1"># Apply scaling and downscaling based on K-correction status</span>
    <span class="k">if</span> <span class="n">apply_kcorrect</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># Without K-correction</span>
        <span class="n">img_downscale</span> <span class="o">=</span> <span class="n">ferengi_downscale</span><span class="p">(</span><span class="n">img_nok</span><span class="p">,</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">],</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">],</span> <span class="n">evo</span><span class="o">=</span><span class="n">evo</span><span class="p">,</span> <span class="n">nofluxscale</span><span class="o">=</span><span class="n">noflux</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># With K-correction</span>
        <span class="n">img_downscale</span><span class="p">,</span> <span class="n">bg</span> <span class="o">=</span> <span class="n">kcorrect_maggies</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">im_err</span><span class="p">,</span> <span class="n">lowz_info</span><span class="p">,</span> <span class="n">highz_info</span><span class="p">,</span> <span class="n">lambda_lo</span><span class="p">,</span> <span class="n">lambda_hi</span><span class="p">,</span> <span class="n">err0_mag</span><span class="p">,</span> <span class="n">evo</span><span class="p">,</span> <span class="n">noflux</span><span class="p">,</span> <span class="n">kc_obj</span><span class="p">)</span>

    <span class="c1"># Replace invalid or zero-value pixels with median values</span>
    <span class="n">med</span> <span class="o">=</span> <span class="n">scndi</span><span class="o">.</span><span class="n">median_filter</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">img_downscale</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">med</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img_downscale</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">img_downscale</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">med</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="c1"># Handle high-sigma pixels if K-correction is applied</span>
    <span class="k">if</span> <span class="n">apply_kcorrect</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">nrej</span> <span class="o">=</span> <span class="n">resistent_mean</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">nrej</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">sig</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">img_downscale</span> <span class="o">!=</span> <span class="n">bg</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;High sigma pixels detected&#39;</span><span class="p">)</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">robust_linefit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">bg</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">fit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">fit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">bg</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>

            <span class="n">m</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">nrej</span> <span class="o">=</span> <span class="n">resistent_mean</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">img_downscale</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">nrej</span><span class="p">)</span>

            <span class="n">idx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="n">sig</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">img_downscale</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">med</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">idx1</span><span class="p">]]</span>

    <span class="c1"># Subtract sky background from the image</span>
    <span class="n">img_downscale</span> <span class="o">-=</span> <span class="n">ring_sky</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">nw</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Output results without convolution if requested</span>
    <span class="k">if</span> <span class="n">noconv</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">dump_results</span><span class="p">(</span><span class="n">img_downscale</span> <span class="o">/</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">],</span> <span class="n">psf_lo</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psf_lo</span><span class="p">),</span> <span class="n">images</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">namesout</span><span class="p">,</span> <span class="n">lowz_info</span><span class="p">,</span> <span class="n">highz_info</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">img_downscale</span> <span class="o">/</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">],</span> <span class="n">psf_lo</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psf_lo</span><span class="p">)</span>

    <span class="c1"># Calculate the transformation PSF</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">psf_low</span><span class="p">,</span> <span class="n">psf_high</span><span class="p">,</span> <span class="n">psf_t</span> <span class="o">=</span> <span class="n">ferengi_transformation_psf</span><span class="p">(</span><span class="n">psf_lo</span><span class="p">,</span> <span class="n">psf_hi</span><span class="p">,</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;redshift&#39;</span><span class="p">],</span> <span class="n">lowz_info</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;pixscale&#39;</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Enlarging PSF failed! Skipping Galaxy.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">99</span><span class="p">,</span> <span class="o">-</span><span class="mi">99</span>

    <span class="c1"># Reconstruct the PSF using convolution</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">psf_lo</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">psf_t</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">psf_lo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">psf_lo</span><span class="p">)</span>
            <span class="n">psf_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">psf_t</span><span class="p">)</span>
        <span class="n">recon_psf</span> <span class="o">=</span> <span class="n">ferengi_psf_centre</span><span class="p">(</span><span class="n">apcon</span><span class="o">.</span><span class="n">convolve_fft</span><span class="p">(</span><span class="n">psf_lo</span><span class="p">,</span> <span class="n">psf_t</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reconstruction PSF failed!&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">99</span><span class="p">,</span> <span class="o">-</span><span class="mi">99</span>

    <span class="c1"># Normalize the reconstructed PSF</span>
    <span class="n">recon_psf</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">recon_psf</span><span class="p">)</span>

    <span class="c1"># Convolve the image with the transformation PSF and add noise if applicable</span>
    <span class="k">if</span> <span class="n">n_bands</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">img_downscale</span> <span class="o">=</span> <span class="n">ferengi_convolve_plus_noise</span><span class="p">(</span><span class="n">img_downscale</span> <span class="o">/</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">],</span> <span class="n">psf_t</span><span class="p">,</span> <span class="n">sky</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">],</span> <span class="n">nonoise</span><span class="o">=</span><span class="n">nonoise</span><span class="p">,</span> <span class="n">border_clip</span><span class="o">=</span><span class="n">border_clip</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="n">extend</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">img_downscale</span> <span class="o">=</span> <span class="n">ferengi_convolve_plus_noise</span><span class="p">(</span><span class="n">img_downscale</span> <span class="o">/</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">],</span> <span class="n">psf_t</span><span class="p">,</span> <span class="n">sky</span><span class="p">[</span><span class="n">idx_bestfilt</span><span class="p">],</span> <span class="n">highz_info</span><span class="p">[</span><span class="s1">&#39;exptime&#39;</span><span class="p">],</span> <span class="n">nonoise</span><span class="o">=</span><span class="n">nonoise</span><span class="p">,</span> <span class="n">border_clip</span><span class="o">=</span><span class="n">border_clip</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="n">extend</span><span class="p">)</span>

    <span class="c1"># Validate the convolved image</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">99</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sky Image not big enough!&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">99</span><span class="p">,</span> <span class="o">-</span><span class="mi">99</span>

    <span class="c1"># Save the results to output files</span>
    <span class="n">dump_results</span><span class="p">(</span><span class="n">img_downscale</span><span class="p">,</span> <span class="n">recon_psf</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">namesout</span><span class="p">,</span> <span class="n">lowz_info</span><span class="p">,</span> <span class="n">highz_info</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img_downscale</span><span class="p">,</span> <span class="n">recon_psf</span></div>

            
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Diego Maldonado, Pierluigi Cerulo, Ana Paulino-Afonso.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>